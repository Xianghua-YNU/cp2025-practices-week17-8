# 项目：常微分方程的松弛迭代法 - 实验报告

**学生姓名：** [秦铭阳] **学号：** [20231050162] **完成日期：** [2025.6.18]

## 1. 实验目的

学习松弛迭代法求解常微分方程边值问题，通过抛体运动实例掌握数值方法的实现。

## 2. 核心算法

### 2.1 算法思路

使用二阶中心差分近似二阶导数，将微分方程转化为差分方程，然后通过松弛迭代法求解边值问题。

### 2.2 关键代码片段

```python
# 松弛迭代核心代码
while delta > tol:
    x_new = np.copy(x)
    x_new[1:-1] = 0.5 * (h * h * g + x[2:] + x[:-2])
    delta = np.max(np.abs(x_new - x))
    x = x_new
```

## 3. 实验结果

### 3.1 主要输出

- 最大高度：[121.59] m
- 到达最大高度时间：[5] s
- 迭代收敛次数：[10] 次

### 3.2 结果验证

- 边界条件满足：x(0) = 0, x(10) = 0
- 轨迹对称性：关于 t = 5s 对称
- 物理合理性：抛体轨迹呈抛物线形状

## 4. 问题与收获

### 4.1 主要问题

1. 收敛条件的设置：如何选择合适的收敛容差 `tol`？如果 `tol` 太大，结果精度可能不足；如果 `tol` 太小，可能需要过多的迭代次数甚至导致计算时间过长或无法收敛。
2. 迭代公式的正确实现：在编写代码时，容易在数组索引上出错，特别是处理边界点时。例如，忘记 `x_new[1:-1]` 只更新内部点，或者错误地包含了边界点进行更新。

### 4.2 解决方法

1. 使用最大变化量作为收敛判据
2. 仔细处理数组索引，确保边界条件
- 收敛条件：采用最大变化量 `delta = np.max(np.abs(x_new - x))` 作为收敛判据，直观且易于实现。通过尝试不同的 `tol` 值（如 `1e-4`, `1e-6`, `1e-8`），观察结果变化和迭代次数，选择一个在精度和计算效率之间取得平衡的值。
- 迭代公式实现：仔细核对差分方程和迭代公式。特别注意 NumPy 数组的索引规则，`x[1:-1]` 确保只更新从第1个到倒数第2个点（即所有内部点），而 `x[2:]` 和 `x[:-2]` 分别代表每个内部点右侧和左侧的邻居点。同时，确保在迭代过程中不改变边界值 `x[0]` 和 `x[-1]`。
### 4.3 主要收获

通过本实验掌握了松弛迭代法的基本原理，理解了边值问题与初值问题的区别，学会了用数值方法求解物理问题。
通过本次实验，我深入理解了松弛迭代法的基本原理和实现步骤。我认识到边值问题（如本实验中的抛体运动，需要指定起点和终点的高度）与初值问题（如直接积分运动方程，需要指定初始位置和速度）在求解思路上的区别。边值问题通常需要将微分方程离散化后求解线性方程组，而初值问题则可以直接使用如欧拉法、龙格-库塔法等进行时间推进。此外，我还初步掌握了如何使用数值方法模拟物理过程，并学会了调试和验证数值计算结果的基本方法。

## 5. 思考题（可选）

1. 为什么松弛法适合求解边值问题而不是初值问题？松弛法本质上是求解一个由微分方程离散化后得到的线性（或非线性）方程组。边值问题天然地提供了方程组中所有未知量的约束（边界条件），使得整个方程组是封闭可解的。松弛法通过迭代修正内部点的值，使其满足由微分方程转化而来的差分关系，最终逼近满足所有条件的解。而初值问题通常只需要知道初始时刻的状态，然后可以通过时间步进的方法（如欧拉法、RK法）逐步计算出后续时刻的状态，不需要同时求解整个域上的所有点，因此更适合使用时间推进的数值方法。

3. 如何选择合适的收敛容差和最大迭代次数？
- 收敛容差 (tol)：应根据所需的解的精度来选择。对于工程应用，可能 `1e-4` 或 `1e-5` 就足够了。对于科学研究或需要高精度结果的情况，可能需要 `1e-8` 或更小。一个实用的方法是先从一个相对较大的容差（如 `1e-4`）开始，运行程序，记录结果和迭代次数。然后逐渐减小容差（如 `1e-5`, `1e-6`），观察结果的变化。当结果在几位有效数字内不再变化时，说明达到了一个合理的精度，此时的容差就是比较合适的选择。同时也要考虑计算成本。
- 最大迭代次数：应设置一个足够大的值，以确保有足够的机会让迭代收敛，但又不能过大以至于在明显不收敛的情况下浪费计算资源。可以先根据问题的规模和初步试验估计一个大致的迭代次数（例如，对于 `N=100`，几百到几千次迭代可能是合理的）。如果程序在达到最大迭代次数前就收敛了，说明设置是合理的；如果达到了最大迭代次数仍未收敛，则需要检查算法、参数设置或考虑增大最大迭代次数，但也要警惕算法本身可能发散的情况。

